{
  "ownKey": "pages",
  "childrenPages": {
    "license": {
      "ownKey": "license",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "license",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/license"
        },
        "description": "",
        "title": "License",
        "content": ""
      }]
    },
    "kaval-arrow": {
      "ownKey": "kaval-arrow",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "kaval-arrow",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/kaval-arrow"
        },
        "description": "",
        "title": "Kaval Arrow",
        "content": "<h1 id=\"kaval-arrow\"><a href=\"#kaval-arrow\" id=\"kaval-arrow\" class=\"anchor\"><\/a>Kaval Arrow<\/h1>\n<p><a href=\"https://arrow-kt.io\">ArrowKt<\/a> is an awesome Kotlin functional library,\nand this module provide some integration with this library.<\/p>\n<h2 id=\"arrow-validated-vs-kaval-validation\"><a href=\"#arrow-validated-vs-kaval-validation\" id=\"arrow-validated-vs-kaval-validation\" class=\"anchor\"><\/a>Arrow Validated vs Kaval validation<\/h2>\n<p>The Kaval approach is to provide an easy way to write and combine some validator, it's just a DSL.\nOn the other side, the <code>Validated<\/code> is based on the type category,\nand implements some HKT like <strong>Functor<\/strong>, <strong>Applicative<\/strong>, <strong>Traverse<\/strong>, ...<\/p>\n<p>Although these are two different approaches of validation, they are not in competition.\nIn my opinion, the idea would be to use Kaval as a DSL to easily declare validation rules,\nand then if we need Arrow's ad hoc polymorphism,\nto transform Kaval validators to provide <code>Validated<\/code> or <code>Either<\/code>.<\/p>\n<p>Another noteworthy point is that Kaval is intended to be multi-platform.<\/p>\n<h2 id=\"provided-validators\"><a href=\"#provided-validators\" id=\"provided-validators\" class=\"anchor\"><\/a>Provided Validators<\/h2>\n<h3 id=\"optiont\"><a href=\"#optiont\" id=\"optiont\" class=\"anchor\"><\/a><code>Option&lt;T&gt;<\/code><\/h3>\n<ul>\n<li><code>isNoneOr(validator: () -&gt; Validator&lt;C&gt;)<\/code>: accept a <code>None<\/code>, or a valid <code>Some<\/code><\/li>\n<li><code>isNone()<\/code>: require a <code>None<\/code>, probably not very useful<\/li>\n<li><code>isSome()<\/code>: require a <code>Some<\/code>, probably not very useful<\/li>\n<\/ul>\n<h3 id=\"eitherl-r\"><a href=\"#eitherl-r\" id=\"eitherl-r\" class=\"anchor\"><\/a><code>Either&lt;L, R&gt;<\/code><\/h3>\n<ul>\n<li><code>validator(leftValidator: () -&gt; Validator&lt;L&gt;, rightValidator: () -&gt; Validator&lt;R&gt;)<\/code>: accept a valid <code>Either.Left<\/code>,\nor a valid <code>Either.Right<\/code><\/li>\n<li><code>isRight()<\/code>: require an <code>Either.Right<\/code><\/li>\n<li><code>isRight(validator: () -&gt; Validator&lt;R&gt;)<\/code>: require a valid <code>Either.Right<\/code><\/li>\n<li><code>isLeft()<\/code>: require an <code>Either.Left<\/code><\/li>\n<li><code>isLeft(validator: () -&gt; Validator&lt;L&gt;)<\/code>: require an <code>Either.Left<\/code><\/li>\n<\/ul>\n<h3 id=\"iorl-r\"><a href=\"#iorl-r\" id=\"iorl-r\" class=\"anchor\"><\/a><code>Ior&lt;L, R&gt;<\/code><\/h3>\n<ul>\n<li><code>validator(leftValidator: () -&gt; Validator&lt;L&gt;, rightValidator: () -&gt; Validator&lt;R&gt;)<\/code>: accept a valid <code>Ior.Left<\/code>,\nor a valid <code>Ior.Right<\/code>, or a valid <code>Ior.Both<\/code><\/li>\n<li><code>isRight()<\/code>: require an <code>Ior.Right<\/code><\/li>\n<li><code>isRight(validator: () -&gt; Validator&lt;R&gt;)<\/code>: require a valid <code>Ior.Right<\/code><\/li>\n<li><code>isLeft()<\/code>: require an <code>Ior.Left<\/code><\/li>\n<li><code>isLeft(validator: () -&gt; Validator&lt;L&gt;)<\/code>: require a valid <code>Ior.Left<\/code><\/li>\n<li><code>isBoth()<\/code>: require an <code>Ior.Both<\/code><\/li>\n<li><code>isLeft(leftValidator: () -&gt; Validator&lt;L&gt;, rightValidator: () -&gt; Validator&lt;R&gt;)<\/code>: require a valid <code>Ior.Both<\/code><\/li>\n<\/ul>\n<h3 id=\"nonemptylistt\"><a href=\"#nonemptylistt\" id=\"nonemptylistt\" class=\"anchor\"><\/a><code>NonEmptyList&lt;T&gt;<\/code><\/h3>\n<ul>\n<li><code>hasSize(size: Int)<\/code>: valid when size has a specific value<\/li>\n<li><code>maxSize(size: Int)<\/code>: valid when size is lower or equals to a specific value<\/li>\n<li><code>minSize(size: Int)<\/code>: valid when size is lower or equals to a specific value<\/li>\n<li><code>allValid(elementValidator: () -&gt; Validator&lt;T&gt;)<\/code>: valid when all elements are valid.<\/li>\n<li><code>atLeastOneValid(elementValidator: () -&gt; Validator&lt;T&gt;)<\/code>: valid when at least one element is valid.<\/li>\n<\/ul>\n<h2 id=\"validation-returning-a-validated\"><a href=\"#validation-returning-a-validated\" id=\"validation-returning-a-validated\" class=\"anchor\"><\/a>Validation returning a Validated<\/h2>\n<p>The <code>KavalValidated<\/code> object provide some useful extension if you want to return an Arrow <code>Validated<\/code>.<\/p>\n<p>A <code>ValidationResult<\/code> is isomorphic to <code>Validated&lt;Nel&lt;ValidationIssue&gt;, Unit&gt;<\/code>, you can use the\n<code>ValidationResult.toValidated(): Validated&lt;Nel&lt;ValidationIssue&gt;, Unit&gt;<\/code> extension function\nto map a validation result to an Arrow <code>Validated<\/code>.<\/p>\n<p>The <code>Validator&lt;T&gt;.validateValidated(t: T): Validated&lt;Nel&lt;ValidationIssue&gt;, T&gt;<\/code> extension function can be used\nto return the Arrow <code>Validated<\/code>.<\/p>\n<p>And you can check an object with a validator like that:<\/p>\n<pre><code class=\"language-kotlin\">// Put the right check method into the scope\nio.monkeypatch.kaval.arrow.KavalValidated.check\n\n// A successful case\nval addressOk = Address(\n    line1 = &quot;42 avenue Monoid&quot;,\n    line2 = &quot;Semigroup block&quot;,\n    zipCode = 42000,\n    city = &quot;LambdaCity&quot;\n)\n\nprintln(addressOk.check(Address.validator))\n// Valid(Address(line1=42 avenue Monoid, line2=Semigroup block, zipCode=42000, city=LambdaCity))\n\n// And a failure case\nval addressKo = Address(\n    line1 = &quot; &quot;.repeat(500),\n    line2 = &quot;&quot;,\n    zipCode = -1,\n    city = &quot;&quot;\n)\n\nprintln(addressKo.check(Address.validator))\n// (indented)\n// Invalid(\n//   NonEmptyList([\n//     [line1] requires to be not blank,\n//     [line1.length] requires to be lower or equals to 255, got 500,\n//     [zipCode] requires to be greater than 0, got -1,\n//     [city] requires to be not blank\n//   ])\n// )\n<\/code><\/pre>\n<h2 id=\"validation-returning-an-either\"><a href=\"#validation-returning-an-either\" id=\"validation-returning-an-either\" class=\"anchor\"><\/a>Validation returning an Either<\/h2>\n<p>The <code>KavalEither<\/code> object provide some useful extension if you perfer returning an Arrow <code>Either<\/code>.<\/p>\n<p>A <code>ValidationResult<\/code> is isomorphic to <code>Either&lt;InvalidException, Unit&gt;<\/code>, you can use the\n<code>ValidationResult.toEither(): Either&lt;InvalidException, Unit&gt;<\/code> extension function\nto map a validation result to an Arrow <code>Validated<\/code>.<\/p>\n<p>The <code>Validator&lt;T&gt;.validateEither(t: T): Either&lt;InvalidException, T&gt;<\/code> extension function can be used\nto return the Arrow <code>Validated<\/code>.<\/p>\n<p>And you can check an object with a validator like that:<\/p>\n<pre><code class=\"language-kotlin\">// Put the right check method into the scope\nio.monkeypatch.kaval.arrow.KavalEither.check\n\n// A successful case\nval addressOk = Address(\n    line1 = &quot;42 avenue Monoid&quot;,\n    line2 = &quot;Semigroup block&quot;,\n    zipCode = 42000,\n    city = &quot;LambdaCity&quot;\n)\n\nprintln(addressOk.check(Address.validator))\n// Right(Address(line1=42 avenue Monoid, line2=Semigroup block, zipCode=42000, city=LambdaCity))\n\n// And a failure case\nval addressKo = Address(\n    line1 = &quot; &quot;.repeat(500),\n    line2 = &quot;&quot;,\n    zipCode = -1,\n    city = &quot;&quot;\n)\n\nprintln(addressKo.check(Address.validator))\n// Left(InvalidException(invalid=Invalid:\n//  - [line1] requires to be not blank\n//  - [line1.length] requires to be lower or equals to 255, got 500\n//  - [zipCode] requires to be greater than 0, got -1\n//  - [city] requires to be not blank))\n<\/code><\/pre>\n"
      }]
    },
    "kaval-kotest": {
      "ownKey": "kaval-kotest",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "kaval-kotest",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/kaval-kotest"
        },
        "description": "",
        "title": "Kaval Kotest",
        "content": "<h1 id=\"kaval-kotest\"><a href=\"#kaval-kotest\" id=\"kaval-kotest\" class=\"anchor\"><\/a>Kaval kotest<\/h1>\n<p>Provide matchers for <a href=\"https://github.com/kotest/kotest\">kotest<\/a><\/p>\n<h2 id=\"provided-matchers\"><a href=\"#provided-matchers\" id=\"provided-matchers\" class=\"anchor\"><\/a>Provided matchers<\/h2>\n<h3 id=\"bevalidfor\"><a href=\"#bevalidfor\" id=\"bevalidfor\" class=\"anchor\"><\/a><code>beValidFor<\/code><\/h3>\n<p>Check an element with his validator<\/p>\n<pre><code class=\"language-kotlin\">val validator: Validator&lt;String&gt; = TODO(&quot;pick your validator&quot;)\n&quot;plop&quot; should beValidFor(validator)\n<\/code><\/pre>\n<h3 id=\"bevalid\"><a href=\"#bevalid\" id=\"bevalid\" class=\"anchor\"><\/a><code>beValid<\/code><\/h3>\n<p>Check a <code>ValidationResult<\/code> is Valid<\/p>\n<pre><code class=\"language-kotlin\">val validator: Validator&lt;String&gt; = TODO(&quot;pick your validator&quot;)\nvalidator.validate(&quot;plop&quot;) should beValid()\n<\/code><\/pre>\n<h3 id=\"beinvalid\"><a href=\"#beinvalid\" id=\"beinvalid\" class=\"anchor\"><\/a><code>beInvalid<\/code><\/h3>\n<p>Check a <code>ValidationResult<\/code> is Invalid<\/p>\n<pre><code class=\"language-kotlin\">val validator: Validator&lt;String&gt; = TODO(&quot;pick your validator&quot;)\nvalidator.validate(&quot;plop&quot;) should beInvalid()\n<\/code><\/pre>\n<h3 id=\"beinvalidonfield\"><a href=\"#beinvalidonfield\" id=\"beinvalidonfield\" class=\"anchor\"><\/a><code>beInvalidOnField<\/code><\/h3>\n<p>Check a <code>ValidationResult<\/code> have an issue on a specific field<\/p>\n<pre><code class=\"language-kotlin\">val validator: Validator&lt;String&gt; = TODO(&quot;pick your validator&quot;)\nvalidator.validate(&quot;plop&quot;) should beInvalidOnField(&quot;length&quot;)\n<\/code><\/pre>\n<h3 id=\"beinvalidwithreason\"><a href=\"#beinvalidwithreason\" id=\"beinvalidwithreason\" class=\"anchor\"><\/a><code>beInvalidWithReason<\/code><\/h3>\n<p>Check a <code>ValidationResult<\/code> have an issue with a specific message<\/p>\n<pre><code class=\"language-kotlin\">val validator: Validator&lt;String&gt; = TODO(&quot;pick your validator&quot;)\nvalidator.validate(&quot;plop&quot;) should beInvalidWithReason(&quot;requires to be not empty&quot;)\n<\/code><\/pre>\n<h3 id=\"beinvalidwithallreasons\"><a href=\"#beinvalidwithallreasons\" id=\"beinvalidwithallreasons\" class=\"anchor\"><\/a><code>beInvalidWithAllReasons<\/code><\/h3>\n<p>Check a <code>ValidationResult<\/code> have some issues with specific messages<\/p>\n<pre><code class=\"language-kotlin\">val validator: Validator&lt;String&gt; = TODO(&quot;pick your validator&quot;)\nvalidator.validate(&quot;plop&quot;) should beInvalidWithAllReasons(\n    &quot;requires to be not empty&quot;,\n    &quot;requires matching '^[a-z]*$'&quot;\n)\n<\/code><\/pre>\n<h3 id=\"beinvalidwithany\"><a href=\"#beinvalidwithany\" id=\"beinvalidwithany\" class=\"anchor\"><\/a><code>beInvalidWithAny<\/code><\/h3>\n<p>Check a <code>ValidationResult<\/code> have an issue matching a kotest <code>Matcher<\/code><\/p>\n<pre><code class=\"language-kotlin\">val validator: Validator&lt;String&gt; = TODO(&quot;pick your validator&quot;)\nvalidator.validate(&quot;plop&quot;) should beInvalidWithAny(beLowerCase())\n<\/code><\/pre>\n"
      }]
    },
    "changelog": {
      "ownKey": "changelog",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "changelog",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/changelog"
        },
        "description": "",
        "title": "Changelog",
        "content": ""
      }]
    },
    "playground": {
      "ownKey": "playground",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "playground",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/playground"
        },
        "description": "",
        "title": "Playground",
        "content": "<h2 id=\"try-it\"><a href=\"#try-it\" id=\"try-it\" class=\"anchor\"><\/a>Try it<\/h2>\n<pre lines=\"true\"><code class=\"language-run-kotlin\" lines=\"true\">fun main() {\n   println(&quot;Running from Kotlin Playground!&quot;)\n}\n<\/code><\/pre>\n"
      }]
    },
    "kaval-core": {
      "ownKey": "kaval-core",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "kaval-core",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/kaval-core"
        },
        "description": "",
        "title": "Kaval Core",
        "content": "<h1 id=\"kaval-core\"><a href=\"#kaval-core\" id=\"kaval-core\" class=\"anchor\"><\/a>Kaval Core<\/h1>\n<p>This is the base of Kaval, here there are definition or commons types like <code>Validator<\/code>, <code>ValidationResult<\/code>,\nand some commons predefine validators.<\/p>\n<h2 id=\"whats-a-validator\"><a href=\"#whats-a-validator\" id=\"whats-a-validator\" class=\"anchor\"><\/a>What's a Validator<\/h2>\n<p>A <code>Validator<\/code> is function that take a value, and return a <code>ValidatorResult<\/code>.\nThe <code>ValidatorResult<\/code> could be a <code>Valid<\/code>, or a <code>Invalid<\/code> object.\nAn the <code>Invalid<\/code> case gather all validation issues.<\/p>\n<p>A <code>ValidationIssue<\/code> always contains a descriptive <code>message<\/code>, and could contain a <code>field<\/code> associated with the issue.<\/p>\n<h2 id=\"validator-usages\"><a href=\"#validator-usages\" id=\"validator-usages\" class=\"anchor\"><\/a>Validator usages<\/h2>\n<p>Imagine we want to validate an integer with an ultimate validator:<\/p>\n<pre><code class=\"language-kotlin\">val ultimateValidator: Validator&lt;Int&gt; = TODO(&quot;See below for creating custom validators&quot;)\n<\/code><\/pre>\n<p>Now we can play with some numbers:<\/p>\n<pre><code class=\"language-kotlin\">println(ultimateValidator.validate(42))\n// Valid\n\nprintln(ultimateValidator.validate(5))\n// Invalid: not the Answer to the Ultimate Question of Life, the Universe, and Everything\n<\/code><\/pre>\n<p>You also can some extension functions:<\/p>\n<pre><code class=\"language-kotlin\">42.isValid(ultimateValidator) // true\n14.isValid(ultimateValidator) // false\n\n42.isValidOrThrow(ultimateValidator) // 42\n24.isValidOrThrow(ultimateValidator) // throw an InvalidException\n<\/code><\/pre>\n<p>If you want to chain the validation you can do something like that:<\/p>\n<pre><code class=\"language-kotlin\">val isDigit: Validator&lt;String&gt; = Strings.matches(Regex(&quot;^[0-9]$&quot;))\n\nfun parseInt(str: String): Int =\n    str.isValidOrThrow(isDigit).toInt()\n\nparseInt(&quot;3&quot;) // 3: Int\n\nparseInt(&quot;foo&quot;) // throw an InvalidException\n<\/code><\/pre>\n<p>You can find more samples <a href=\"../samples/src/main/kotlin\">here<\/a><\/p>\n<h2 id=\"combine-validators\"><a href=\"#combine-validators\" id=\"combine-validators\" class=\"anchor\"><\/a>Combine Validators<\/h2>\n<p>Validators can be combined with <code>and<\/code>, <code>andThen<\/code>, <code>or<\/code><\/p>\n<ul>\n<li><code>and<\/code>: run both validators and gather all issues<\/li>\n<li><code>andThen<\/code>: run the first validator, if valid, try the second one. This is a <em>fail fast<\/em> solution to stop after first issue.<\/li>\n<li><code>or<\/code>: run the first validator, if invalid try the second one.<\/li>\n<\/ul>\n<p>Let's try it with two validators:<\/p>\n<pre><code class=\"language-kotlin\">val v1 = Strings.maxLength(3)\nval v2 = Strings.matches(Regex(&quot;^[a-z]*$&quot;))\n<\/code><\/pre>\n<p>And validate some inputs:<\/p>\n<table>\n<thead>\n<tr><th>input<\/th><th><code>v1 and v2<\/code><\/th><th><code>v1 andThen v2<\/code><\/th><th><code>v1 or v2<\/code><\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td><code>&quot;&quot;<\/code><\/td><td>Valid<\/td><td>Valid<\/td><td>Valid<\/td><\/tr>\n<tr><td><code>&quot;abc&quot;<\/code><\/td><td>Valid<\/td><td>Valid<\/td><td>Valid<\/td><\/tr>\n<tr><td><code>&quot;A&quot;<\/code><\/td><td>Invalid: requires matching '^[a-z]*$'<\/td><td>Invalid: requires matching '^[a-z]*$'<\/td><td>Valid<\/td><\/tr>\n<tr><td><code>&quot;Abcef&quot;<\/code><\/td><td>Invalid:<br> - [length] requires to be lower or equals to 3, got 5<br> - requires matching '^[a-z]*$'<\/td><td>Invalid: [length] requires to be lower or equals to 3, got 5<\/td><td>Invalid:<br> - [length] requires to be lower or equals to 3, got 5<br> - requires matching '^[a-z]*$'<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h2 id=\"provided-validators\"><a href=\"#provided-validators\" id=\"provided-validators\" class=\"anchor\"><\/a>Provided validators<\/h2>\n<h3 id=\"commons\"><a href=\"#commons\" id=\"commons\" class=\"anchor\"><\/a>Commons<\/h3>\n<p>Into the package <code>io.monkeypatch.kaval.core<\/code><\/p>\n<ul>\n<li><code>alwaysValid<\/code>: an always valid validator, could be useful in test, or when folding a list of validators.<\/li>\n<li><code>alwaysInvalid(reason: String)<\/code>: an always invalid validator, could be useful in test, or when folding a list of Validators.<\/li>\n<li><code>predicate(predicate: (T) -&gt; Boolean, reason: (T) -&gt; String)<\/code>: build a validator based on a predicate. Useful to create your own validator.<\/li>\n<li><code>notNull()<\/code>: valid when element is not null.<\/li>\n<li><code>containsBy(iter: Iterable&lt;T&gt;)<\/code>: valid when element is into the iterable<\/li>\n<li><code>notContainsBy(iter: Iterable&lt;T&gt;)<\/code>: valid when element is not into the iterable<\/li>\n<li><code>nullOr(validator: () -&gt; Validator&lt;T&gt;)<\/code>: valid if the element is null or if it's valid for the provided sub-validator.<\/li>\n<li><code>field(fieldName: String, fieldExtractor: (H) -&gt; C, fieldValidator: () -&gt; Validator&lt;C&gt;)<\/code>: validate a field of an element.\nNote that there is a <code>property<\/code> validator define into the <code>kaval-reflect<\/code> module.<\/li>\n<li><code>isInstance&lt;T&gt;()<\/code>: validate when element is an instance of a specific type.<\/li>\n<li><code>whenIsInstance(uValidator: () -&gt; Validator&lt;U&gt;)<\/code>: allow validation of the element when it's a specific instance.\nUseful to validate sealed class. See this <a href=\"../samples/src/main/kotlin/sealed.kt\">sample<\/a><\/li>\n<\/ul>\n<h3 id=\"strings\"><a href=\"#strings\" id=\"strings\" class=\"anchor\"><\/a>Strings<\/h3>\n<p>Into the object <code>io.monkeypatch.kaval.core.validator.Strings<\/code><\/p>\n<ul>\n<li><code>notEmpty<\/code>: valid for a not empty char sequence.<\/li>\n<li><code>notBlank<\/code>: valid for a not blank char sequence.<\/li>\n<li><code>hasLength(length: Int)<\/code>: valid when the char sequence has a specific length.<\/li>\n<li><code>maxLength(length: Int)<\/code>: valid when the char sequence has a length lower or equals to a specific length.<\/li>\n<li><code>minLength(length: Int)<\/code>: valid when the char sequence has a length greater or equals to a specific length.<\/li>\n<li><code>matches(regex: Regex, message: String)<\/code>: valid when the char sequence match the regex. The message is optional.<\/li>\n<\/ul>\n<h3 id=\"comparables\"><a href=\"#comparables\" id=\"comparables\" class=\"anchor\"><\/a>Comparables<\/h3>\n<p>Into the object <code>io.monkeypatch.kaval.core.validator.Comparables<\/code><\/p>\n<ul>\n<li><code>greaterThan(value: T)<\/code>, <code>greaterThan(value: T, comparator: Comparator&lt;T&gt;)<\/code>: valid for when <code>&gt;<\/code>, you can provide a <code>Comparator<\/code>.<\/li>\n<li><code>greaterOrEqualTo(value: T)<\/code>, <code>greaterOrEqualTo(value: T, comparator: Comparator&lt;T&gt;)<\/code>: valid for when <code>&gt;=<\/code>, you can provide a <code>Comparator<\/code>.<\/li>\n<li><code>lowerThan(value: T)<\/code>, <code>lowerThan(value: T, comparator: Comparator&lt;T&gt;)<\/code>: valid for when <code>&lt;<\/code>, you can provide a <code>Comparator<\/code>.<\/li>\n<li><code>lowerOrEqualTo(value: T)<\/code>, <code>lowerOrEqualTo(value: T, comparator: Comparator&lt;T&gt;)<\/code>: valid for when <code>&lt;=<\/code>, you can provide a <code>Comparator<\/code>.<\/li>\n<li><code>equalTo(value: T)<\/code>, <code>equalTo(value: T, comparator: Comparator&lt;T&gt;)<\/code>: valid for when <code>==<\/code>, you can provide a <code>Comparator<\/code>.<\/li>\n<li><code>inClosedRange(range: ClosedRange&lt;T&gt;)<\/code>: valid for when <code>in<\/code> the range.<\/li>\n<\/ul>\n<h3 id=\"numbers\"><a href=\"#numbers\" id=\"numbers\" class=\"anchor\"><\/a>Numbers<\/h3>\n<p>Numbers implements <code>Comparable<\/code>, so you can already use methods like <code>greaterThan<\/code>, <code>lowerOrEqualTo<\/code>, ...<\/p>\n<p>Into objects <code>io.monkeypatch.kaval.core.validator.{Ints, Longs, Floats, Doubles}<\/code><\/p>\n<ul>\n<li><code>inRange(range)<\/code>: valid for when <code>in<\/code> the range. The range type depend on the type of validator<\/li>\n<li><code>strictlyPositive<\/code>: valid when <code>&gt;<\/code> 0<\/li>\n<li><code>positive<\/code>: valid when <code>&gt;=<\/code> 0<\/li>\n<li><code>strictlyNegative<\/code>: valid when <code>&lt;<\/code> 0<\/li>\n<li><code>negative<\/code>: valid when <code>&lt;=<\/code> 0<\/li>\n<\/ul>\n<h3 id=\"collections\"><a href=\"#collections\" id=\"collections\" class=\"anchor\"><\/a>Collections<\/h3>\n<p>Into the object <code>io.monkeypatch.kaval.core.validator.Collections<\/code><\/p>\n<ul>\n<li><code>empty()<\/code>: valid if empty<\/li>\n<li><code>notEmpty()<\/code>: valid if not empty<\/li>\n<li><code>hasSize(size: Int)<\/code>: valid when size has a specific value<\/li>\n<li><code>maxSize(size: Int)<\/code>: valid when size is lower or equals to a specific value<\/li>\n<li><code>minSize(size: Int)<\/code>: valid when size is lower or equals to a specific value<\/li>\n<li><code>allValid(elementValidator: () -&gt; Validator&lt;T&gt;)<\/code>: validate an <code>Iterable&lt;T&gt;<\/code> when all elements are valid. Valid when empty.<\/li>\n<li><code>atLeastOneValid(elementValidator: () -&gt; Validator&lt;T&gt;)<\/code>: validate an <code>Iterable&lt;T&gt;<\/code> when at least one element is valid. Invalid if empty.<\/li>\n<li><code>allValuesValid(valueValidator: () -&gt; Validator&lt;V&gt;)<\/code>: validate a <code>Map&lt;K,V&gt;<\/code> when all values are valid. Valid when empty.<\/li>\n<li><code>allKeysValid(keyValidator: () -&gt; Validator&lt;K&gt;)<\/code>: validate a <code>Map&lt;K,V&gt;<\/code> when all keys are valid. Valid when empty.<\/li>\n<li><code>allEntriesValid(entryValidator: () -&gt; Validator&lt;Map.Entry&lt;K, V&gt;&gt;)<\/code>: validate a <code>Map&lt;K,V&gt;<\/code> when all entries are valid. Valid when empty.<\/li>\n<li><code>entryValidator(keyValidator: Validator&lt;K&gt;, valueValidator: Validator&lt;V&gt;)<\/code>: validate a <code>Map.Entry&lt;K,V&gt;<\/code> with a key and a value validator.<\/li>\n<li><code>atLeastOneValueValid(valueValidator: () -&gt; Validator&lt;V&gt;)<\/code>: validate a <code>Map&lt;K,V&gt;<\/code> when at least one value is valid. Invalid if empty.<\/li>\n<li><code>atLeastOneKeyValid(keyValidator: () -&gt; Validator&lt;K&gt;)<\/code>: validate a <code>Map&lt;K,V&gt;<\/code> when at least one key is valid. Invalid if empty.<\/li>\n<li><code>atLeastOneEntryValid(entryValidator: () -&gt; Validator&lt;Map.Entry&lt;K, V&gt;&gt;)<\/code>: validate a <code>Map&lt;K,V&gt;<\/code> when at least one entry is valid. Invalid if empty.<\/li>\n<\/ul>\n<h2 id=\"tuples\"><a href=\"#tuples\" id=\"tuples\" class=\"anchor\"><\/a>Tuples<\/h2>\n<ul>\n<li><code>pair(tValidator: Validator&lt;T&gt;, uValidator: Validator&lt;U&gt;)<\/code>: create a validator for a <code>Pair&lt;T, U&gt;<\/code><\/li>\n<li><code>triple(tValidator: Validator&lt;T&gt;, uValidator: Validator&lt;U&gt;, wValidator: Validator&lt;W&gt;)<\/code>: create a validator for a <code>Triple&lt;T, U, W&gt;<\/code><\/li>\n<\/ul>\n<h2 id=\"create-your-validator\"><a href=\"#create-your-validator\" id=\"create-your-validator\" class=\"anchor\"><\/a>Create your Validator<\/h2>\n<p>You can of course combine already existing validators.\nIt's also quite easy to create your own validator, first we can use the <code>validator(block: (T) -&gt; ValidationResult)<\/code> function:<\/p>\n<pre><code class=\"language-kotlin\">val ultimateValidator: Validator&lt;Int&gt; = validator { i: Int -&gt;\n    if (i == 42) Valid\n    else Invalid(&quot;not the Answer to the Ultimate Question of Life, the Universe, and Everything&quot;)\n}\n<\/code><\/pre>\n<p>Another solution is to use the <code>predicate<\/code> validator:<\/p>\n<pre><code class=\"language-kotlin\">val ultimateValidator: Validator&lt;Int&gt; =\n    predicate({it == 42}) { &quot;not the Answer to the Ultimate Question of Life, the Universe, and Everything&quot;}\n<\/code><\/pre>\n<h2 id=\"jvm-only-validators\"><a href=\"#jvm-only-validators\" id=\"jvm-only-validators\" class=\"anchor\"><\/a>JVM only validators<\/h2>\n<ul>\n<li>\n<p><code>property(property: KProperty&lt;C&gt;, childValidator: () -&gt; Validator&lt;C&gt;)<\/code>: validate a property,\nsame as <code>field<\/code> validator but we does not need to provide the field name.<\/p>\n<\/li>\n<li>\n<p><code>reflectValidator<\/code> function create a validator based on properties<\/p>\n<\/li>\n<\/ul>\n<pre><code class=\"language-kotlin\">// A simple POJO\ndata class Address(\n    val line1: String,\n    val line2: String,\n    val zipCode: Int,\n    val city: String\n)\n\n// And the validator\nval validator: Validator&lt;Address&gt; =\n    reflectValidator {\n        Address::line1 { notBlank and maxLength(255) }\n        Address::line2 { maxLength(255) }\n        Address::zipCode { greaterThan(0) }\n        Address::city { notBlank }\n    }\n<\/code><\/pre>\n"
      }]
    },
    "contributors": {
      "ownKey": "contributors",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "contributors",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/contributors"
        },
        "description": "",
        "title": "Contributors",
        "content": "<h2 id=\"contributors\"><a href=\"#contributors\" id=\"contributors\" class=\"anchor\"><\/a>Contributors<\/h2>\n<ul>\n<li><a href=\"https://github.com/ilaborie\">Igor Laborie<\/a><\/li>\n<\/ul>\n<h2 id=\"contributing\"><a href=\"#contributing\" id=\"contributing\" class=\"anchor\"><\/a>Contributing<\/h2>\n<p>Suggestions and contributions are welcome.<\/p>\n<ul>\n<li><strong>Issues<\/strong>: You can discuss and raise issues on <a href=\"https://github.com/MonkeyPatchIo/kaval/issues\">GitHub<\/a>.<\/li>\n<\/ul>\n<p>When submitting a pull request, please add yourself to the contributors section in <a href=\"https://github.com/MonkeyPatchIo/kaval/blob/master/documentation/src/orchid/resources/data/contributors.yml\">this yaml file<\/a> so that you get proper credit in the project documentation.<\/p>\n"
      }]
    },
    "kaval-coroutine": {
      "ownKey": "kaval-coroutine",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "kaval-coroutine",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/kaval-coroutine"
        },
        "description": "",
        "title": "Kaval Coroutine",
        "content": "<h1 id=\"kaval-coroutine\"><a href=\"#kaval-coroutine\" id=\"kaval-coroutine\" class=\"anchor\"><\/a>Kaval Coroutine<\/h1>\n<p>Sometime, your want to write a custom function is <code>suspend<\/code>, you cannot use the standard <code>Validator&lt;T&gt;<\/code>.\nThis module introduces the <code>SuspendValidator&lt;T&gt;<\/code> validator for <em>red<\/em> functions.<\/p>\n<p>Further reading: <a href=\"https://medium.com/@elizarov/how-do-you-color-your-functions-a6bb423d936d\">How do you color your functions?<\/a><\/p>\n<p>Note: see <a href=\"../kaval-core\"><code>kaval-core<\/code><\/a> before using the <code>kaval-coroutine<\/code> module.<\/p>\n<h2 id=\"provided-suspendvalidator\"><a href=\"#provided-suspendvalidator\" id=\"provided-suspendvalidator\" class=\"anchor\"><\/a>Provided SuspendValidator<\/h2>\n<p>Into the package <code>io.monkeypatch.kaval.coroutine<\/code><\/p>\n<ul>\n<li><code>Validator&lt;T&gt;.toSuspend()<\/code>: transform a <code>Validator<\/code> to a <code>SuspendValidator<\/code><\/li>\n<li><code>predicate(predicate: suspend (T) -&gt; Boolean, reason: (T) -&gt; String)<\/code>: build a validator based on a predicate.<\/li>\n<li><code>nullOr(validator: suspend () -&gt; Validator&lt;T&gt;)<\/code>: valid if the element is null or if it's valid for the provided sub-validator.<\/li>\n<li><code>field(fieldName: String, fieldExtractor: (H) -&gt; C, fieldValidator: suspend () -&gt; Validator&lt;C&gt;)<\/code>: validate a field of an element.<\/li>\n<li><code>whenIsInstance(uValidator: suspend () -&gt; Validator&lt;U&gt;)<\/code>: allow validation of the element when it's a specific instance.<\/li>\n<\/ul>\n<h2 id=\"combining-suspendvalidator\"><a href=\"#combining-suspendvalidator\" id=\"combining-suspendvalidator\" class=\"anchor\"><\/a>Combining SuspendValidator<\/h2>\n<p>You can combine validators with:<\/p>\n<ul>\n<li><code>suspendValidator and classicValidator<\/code>: just run both validators, and aggregate results<\/li>\n<li><code>suspendValidator and suspendValidator<\/code>: run both validators (could be in parallel), and aggregate results<\/li>\n<li><code>suspendValidator andThen classicValidator<\/code>: run first validator, and if in success, run the second validator<\/li>\n<li><code>suspendValidator andThen suspendValidator<\/code>: run first validator, and if in success, run the second validator<\/li>\n<li><code>suspendValidator or classicValidator<\/code>: run both validators, only one success is require to be successful<\/li>\n<li><code>suspendValidator or suspendValidator<\/code>: run both validators (could be in parallel), only one success is require to be successful<\/li>\n<\/ul>\n<h2 id=\"extensions\"><a href=\"#extensions\" id=\"extensions\" class=\"anchor\"><\/a>Extensions<\/h2>\n<ul>\n<li><code>suspend fun &lt;T&gt; T.isValid(validator: SuspendValidator&lt;T&gt;): Boolean<\/code>: check if a POJO is valid<\/li>\n<li><code>suspend fun &lt;T&gt; T.isValidOrThrow(validator: SuspendValidator&lt;T&gt;): Boolean<\/code>: check if a POJO is valid, otherwise throw an <code>InvalidException<\/code><\/li>\n<\/ul>\n"
      }]
    },
    "samples": {
      "ownKey": "samples",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "samples",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/samples"
        },
        "description": "",
        "title": "Samples",
        "content": "<h1 id=\"samples\"><a href=\"#samples\" id=\"samples\" class=\"anchor\"><\/a>Samples<\/h1>\n<p>You can retrieve all these samples into the <a href=\"https://github.com/MonkeyPatchIo/kaval/tree/master/samples/src/main/kotlin\">Github repository<\/a><\/p>\n<h2 id=\"validate-a-pojo\"><a href=\"#validate-a-pojo\" id=\"validate-a-pojo\" class=\"anchor\"><\/a>Validate a POJO<\/h2>\n<p>Let's write a validator for each POJO, here we use the companion object to declare the validator.<\/p>\n<pre><code class=\"language-kotlin\">import io.monkeypatch.kaval.core.Validator\nimport io.monkeypatch.kaval.core.nullOr\nimport io.monkeypatch.kaval.core.validator.Comparables.greaterThan\nimport io.monkeypatch.kaval.core.validator.Strings.maxLength\nimport io.monkeypatch.kaval.core.validator.Strings.notBlank\nimport io.monkeypatch.kaval.reflect.reflectValidator\n\ndata class User(\n    val firstName: String,\n    val lastName: String,\n    val address: Address?\n) {\n    companion object {\n     /**\n      * A [User] is valid when:\n      * - firstName is not blank and length &lt;= 128\n      * - lastName is not blank and length &lt;= 255\n      * - address is valid if not null\n      */\n     val validator: Validator&lt;User&gt; =\n         reflectValidator {\n             User::firstName { notBlank and maxLength(128) }\n             User::lastName { notBlank and maxLength(255) }\n             User::address { nullOr { Address.validator } }\n         }\n    }\n}\n\ndata class Address(\n    val line1: String,\n    val line2: String,\n    val zipCode: Int,\n    val city: String\n) {\n    companion object {\n     /**\n      * An [Address] is valid when:\n      * - the line1 is not blank and length &lt;= 255\n      * - the line2 length &lt;= 255\n      * - the zipCode is &gt; 0\n      * - the city is not blank\n      */\n     val validator: Validator&lt;Address&gt; =\n         reflectValidator {\n             Address::line1 { notBlank and maxLength(255) }\n             Address::line2 { maxLength(255) }\n             Address::zipCode { greaterThan(0) }\n             Address::city { notBlank }\n         }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"validate-a-nullable-object\"><a href=\"#validate-a-nullable-object\" id=\"validate-a-nullable-object\" class=\"anchor\"><\/a>Validate a nullable object<\/h2>\n<p>To validate an object only when it's not null, use the <code>io.monkeypatch.kaval.core.nullOr<\/code><\/p>\n<pre><code class=\"language-kotlin\">import io.monkeypatch.kaval.core.Validator\nimport io.monkeypatch.kaval.core.nullOr\nimport io.monkeypatch.kaval.core.validator.Strings.matches\n\n/**\n * A validator that accept null, or a String matching [Regex] `pl.*p`\n */\nval plopValidator: Validator&lt;String?&gt; = nullOr {\n    matches(Regex(&quot;pl.*p&quot;))\n}\n<\/code><\/pre>\n<h2 id=\"validate-a-collection\"><a href=\"#validate-a-collection\" id=\"validate-a-collection\" class=\"anchor\"><\/a>Validate a collection<\/h2>\n<p>You can retrieve some useful collection validators <a href=\"./kaval-core#collections\">here<\/a><\/p>\n<pre><code class=\"language-kotlin\">import io.monkeypatch.kaval.core.Validator\nimport io.monkeypatch.kaval.core.validator.Collections.allValid\nimport io.monkeypatch.kaval.core.validator.Comparables.greaterThan\n\n/**\n * Validate a list of int, where all int should be &gt; 9\n */\nval listValidator: Validator&lt;List&lt;Int&gt;&gt; = allValid { greaterThan(9) }\n<\/code><\/pre>\n<h3 id=\"validate-a-sealed-class\"><a href=\"#validate-a-sealed-class\" id=\"validate-a-sealed-class\" class=\"anchor\"><\/a>Validate a sealed class<\/h3>\n<p>You can combine validators that matching sub-classes with <code>io.monkeypatch.kaval.core.whenIsInstance<\/code><\/p>\n<pre><code class=\"language-kotlin\">import io.monkeypatch.kaval.core.Validator\nimport io.monkeypatch.kaval.core.field\nimport io.monkeypatch.kaval.core.validator.Ints.inRange\nimport io.monkeypatch.kaval.core.whenIsInstance\n\n/**\n * Let's define a sealed hierarchy for HttpStatus\n */\nsealed class HttpStatus {\n\n    data class Ok(val statusCode: Int) : HttpStatus()\n\n    data class Error(val statusCode: Int) : HttpStatus()\n\n    data class ServerError(val statusCode: Int) : HttpStatus()\n\n    companion object {\n\n        /**\n         * Validate the status statusCode for each HttpStatus variant\n         */\n        val validator: Validator&lt;HttpStatus&gt; = whenIsInstance&lt;HttpStatus, Ok&gt; {\n            // Only check when is an instance of HttpStatus.Ok\n            field(&quot;statusCode&quot;, Ok::statusCode) { inRange(200..299) }\n        } and whenIsInstance {\n            // Only check when is an instance of HttpStatus.Error\n            field(&quot;statusCode&quot;, Error::statusCode) { inRange(400..499) }\n        } and whenIsInstance {\n            // Only check when is an instance of HttpStatus.ServerError\n            field(&quot;statusCode&quot;, ServerError::statusCode) { inRange(500..599) }\n        }\n    }\n}\n<\/code><\/pre>\n<h3 id=\"using-arrow-validated\"><a href=\"#using-arrow-validated\" id=\"using-arrow-validated\" class=\"anchor\"><\/a>Using Arrow Validated<\/h3>\n<p>If you import the <code>io.monkeypatch.kaval.arrow.KavalValidated.check<\/code> extension, you can return an Arrow <code>Validated<\/code><\/p>\n<pre><code class=\"language-kotlin\">import io.monkeypatch.kaval.arrow.KavalValidated.check\n\nval addressOk = Address(\n    line1 = &quot;42 avenue Monoid&quot;,\n    line2 = &quot;Semigroup block&quot;,\n    zipCode = 42000,\n    city = &quot;LambdaCity&quot;\n)\n\nval addressKo = Address(\n    line1 = &quot; &quot;.repeat(500),\n    line2 = &quot;&quot;,\n    zipCode = -1,\n    city = &quot;&quot;\n)\n\nprintln(addressOk.check(Address.validator))\n// Valid(Address(line1=42 avenue Monoid, line2=Semigroup block, zipCode=42000, city=LambdaCity))\n\nprintln(addressKo.check(Address.validator))\n// Invalid(\n//   NonEmptyList([\n//     [line1] requires to be not blank,\n//     [line1.length] requires to be lower or equals to 255, got 500,\n//     [zipCode] requires to be greater than 0, got -1,\n//     [city] requires to be not blanks\n//   ])\n// )\n<\/code><\/pre>\n<h3 id=\"using-arrow-either\"><a href=\"#using-arrow-either\" id=\"using-arrow-either\" class=\"anchor\"><\/a>Using Arrow Either<\/h3>\n<p>If you import the <code>io.monkeypatch.kaval.arrow.KavalEither.check<\/code> extension, you can return an Arrow <code>Either<\/code><\/p>\n<pre><code class=\"language-kotlin\">import io.monkeypatch.kaval.arrow.KavalEither.check\n\nval addressOk = Address(\n    line1 = &quot;42 avenue Monoid&quot;,\n    line2 = &quot;Semigroup block&quot;,\n    zipCode = 42000,\n    city = &quot;LambdaCity&quot;\n)\n\nval addressKo = Address(\n    line1 = &quot; &quot;.repeat(500),\n    line2 = &quot;&quot;,\n    zipCode = -1,\n    city = &quot;&quot;\n)\n\nprintln(addressOk.check(Address.validator))\n// Right(Address(line1=42 avenue Monoid, line2=Semigroup block, zipCode=42000, city=LambdaCity))\n\nprintln(addressKo.check(Address.validator))\n// Left(InvalidException(invalid=Invalid:\n//  - [line1] requires to be not blank\n//  - [line1.length] requires to be lower or equals to 255, got 500\n//  - [zipCode] requires to be greater than 0, got -1\n//  - [city] requires to be not blank))\n<\/code><\/pre>\n"
      }]
    },
    "dependencies": {
      "ownKey": "dependencies",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://monkeypatch.io/kaval",
          "fileName": "dependencies",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://monkeypatch.io/kaval/dependencies"
        },
        "description": "",
        "title": "Dependencies",
        "content": "<h2 id=\"gradle-with-kts\"><a href=\"#gradle-with-kts\" id=\"gradle-with-kts\" class=\"anchor\"><\/a>Gradle with KTS<\/h2>\n<pre><code class=\"language-kotlin\">TODO()\n<\/code><\/pre>\n<h2 id=\"gradle\"><a href=\"#gradle\" id=\"gradle\" class=\"anchor\"><\/a>Gradle<\/h2>\n<pre><code class=\"language-groovy\">TODO()\n<\/code><\/pre>\n<h2 id=\"maven\"><a href=\"#maven\" id=\"maven\" class=\"anchor\"><\/a>Maven<\/h2>\n<pre><code class=\"language-xml\">&lt;todo&gt;&lt;/todo&gt;\n<\/code><\/pre>\n"
      }]
    }
  }
}